/* -*- c -*- */
#if !defined INCLUDED_yuck_h_
#define INCLUDED_yuck_h_

#include <stddef.h>

#define YUCK_OPTARG_NONE	((void*)0x1U)

enum yuck_cmds_e {
pushdef([last], yuck_cmd())pushdef([first], defn([last]))[]dnl
	/* value used when no command was specified */
	first,

	/* actual commands */
	foreachq([cmd], yuck_cmds(), [define([last], yuck_cmd(defn([cmd])))[]last,
	])
	/* convenience identifiers */
	YUCK_NONE = first,
	YUCK_NCMDS = last
popdef([last])popdef([first])[]dnl
};

define([yuck_slot_predecl], [dnl
yuck_iftype([$1], [$2],
	[arg,mul], [size_t ]yuck_canon([$1], [$2])[_nargs],
	[arg,mul,opt], [size_t ]yuck_canon([$1], [$2])[_nargs],
)dnl
])dnl

define([yuck_slot_decl], [dnl
pushdef([pre],dnl
yuck_iftype([$1], [$2],
	[arg,mul], [yuck_slot_predecl([$1], [$2]); ],
	[arg,mul,opt], [yuck_slot_predecl([$1], [$2]); ],
))dnl
pushdef([decl],dnl
yuck_iftype([$1], [$2],
	[flag], [unsigned int ],
	[arg], [const char *],
	[arg,opt], [const char *],
	[arg,mul], [const char **],
	[arg,mul,opt], [const char **],
))dnl
ifelse(decl, [], [], [pre[]decl[]yuck_slot_identifier([$1], [$2]);
])])dnl

struct yuck_s {
	enum yuck_cmds_e cmd;

	/* left-over arguments, the command string is never a part of this */
	size_t nargs;
	char *const *args;

	foreachq([slot], yuck_idents(), [dnl
	yuck_slot_decl(defn([slot]))])
	/* depending on CMD at most one of the following structs is filled in
	 * if CMD is YUCK_NONE no slots of this union must be accessed */
	union {foreachq([cmd], yuck_cmds(), [
		/* for the cmd command */
		struct {
foreachq([slot], yuck_idents(defn([cmd])), [dnl
			yuck_slot_decl(defn([slot]), defn([cmd]))])[]dnl
		} cmd;
])[]dnl
	};
};

foreachq([cmd], yuck_cmds(), [
/* convenience structure for `cmd' */
struct yuck_cmd_[]defn([cmd])[]_s {
	enum yuck_cmds_e cmd;

	/* left-over arguments, the command string is never a part of this */
	size_t nargs;
	char *const *args;
foreachq([slot], yuck_idents(), [dnl
	yuck_slot_decl(defn([slot]))])
foreachq([slot], yuck_idents(defn([cmd])), [dnl
	yuck_slot_decl(defn([slot]), defn([cmd]))])[]dnl
};
])

pushdef([DECLF], ifdef([YUCK_HEADER], [extern], [static]))[]dnl
DECLF int yuck_parse(struct yuck_s *restrict, int argc, char *const argv[[]]);
DECLF void yuck_free(struct yuck_s *restrict);
popdef([DECLF])[]dnl

#endif	/* INCLUDED_yuck_h_ */
