/* -*- c -*- */
#if defined HAVE_CONFIG_H
# include "config.h"
#endif	/* HAVE_CONFIG_H */
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include "yuck.h"

#if defined __INTEL_COMPILER
# pragma warning (disable:177)
#endif	/* __INTEL_COMPILER */


static inline bool
streqp(const char *s1, const char *s2)
{
	return !strcmp(s1, s2);
}

static enum yuck_cmds_e parse_cmd(const char *cmd)
{
	if (0) {
		;
	}foreachq([__cmd__], [YUCK_CMDS], [ else if (streqp(cmd, YUCK_MAP(string, __cmd__))) {
		return __cmd__;
	}]) else {
		/* error here? */
		fprintf(stderr, "`%s' is not a valid command.  See --help.\n", cmd);
	}
	return (enum yuck_cmds_e)-1;
}


int yuck_parse(struct yuck_s *restrict tgt, int argc, char *const argv[[]])
{
	const char *op;
	char **args;
	int i;

	/* we'll have at most this many args */
	tgt->args = args = calloc(argc, sizeof(*tgt->args));
	tgt->nargs = 0U;
	tgt->cmd = (enum yuck_cmds_e)0U;
	for (i = 1; i < argc; i++) {
		op = argv[[i]];

		switch (*op) {
		case '-':
			/* could be an option */
			switch (*++op) {
			case '-':
				if (*++op == '\0') {
					yield(dashdash);
					break;
				}
				yield(longopt, op);
				break;
			default:
				/* could be glued into one */
				for (; *op; op++) {
					yield(shortopt, *op);
				}
				break;
			}
			break;
		default:
			yield(arg, op);
			break;
		}
	}
	return 0;

	coroutine(longopt)
	{
		/* split into option and arg part */
		char *arg;

		if ((arg = strchr(op, '=')) != NULL) {
			/* \nul this one out */
			*arg++ = '\0';
		}

		switch (tgt->cmd) {
		common_longopt:
		default:
			printf("got common longopt `%s'\n", op);
			yield([yuck_NONE_longopt]);
			break;
		foreachq([__cmd__], [YUCK_CMDS], [case __cmd__:
			printf("got __cmd__ longopt `%s'\n", op);
			yield(__cmd__[_longopt]);
			break;
		])}
		resume;

		foreachq([__cmd__], [yuck_NONE,YUCK_CMDS], [coroutine(__cmd__[]_longopt)
		{
			if (0) {
				;
			}foreachq([__lopt__], []__cmd__[_LONG], [ else if (streqp(op, "__lopt__")) {
				YUCK_SET([tgt], __cmd__[.]__lopt__, [arg ?: argv[[++i]]]);
			}])
			resume;
		}
		])
	}

	coroutine(shortopt)
	{
		const char *arg = op + 1U;

		switch (tgt->cmd) {
		common_shortopt:
		default:
			printf("got common shortopt `%c'\n", *op);
			yield([yuck_NONE_shortopt])
			break;
		foreachq([__cmd__], [YUCK_CMDS], [case __cmd__:
			printf("got __cmd__ shortopt `%c'\n", *op);
			yield(__cmd__[_shortopt]);
			break;
		])}
		resume;

		foreachq([__cmd__], [yuck_NONE,YUCK_CMDS], [coroutine(__cmd__[]_shortopt)
		{
			switch (*op) {
			default:
				/* error? */
				break;
			foreachq([__sopt__], []__cmd__[_SHORT], [case '__sopt__':
				YUCK_SET([tgt], __cmd__[.]__sopt__, [dnl
*arg ? arg : argv[[++i]]]);
				break;
			])}
			resume;
		}
		])
	}

	coroutine(arg)
	{
		if (tgt->cmd || !yuck_NCMDS) {
			args[[tgt->nargs++]] = argv[[i]];
		} else {
			/* ah, might be an arg then */
			if ((tgt->cmd = parse_cmd(op)) > yuck_NCMDS) {
				return -1;
			}
		}
		resume;
	}

	coroutine(dashdash)
	{
		/* dashdash loop, pile everything on tgt->args
		 * don't check for subcommands either, this is in accordance to
		 * the git tool which won't accept commands after -- */
		for (i++; i < argc; i++) {
			args[[tgt->nargs++]] = argv[[i]];
		}
		return 0;
	}
}

void yuck_free(struct yuck_s *restrict tgt)
{
	if (tgt->args != NULL) {
		/* free despite const qualifier */
		free((char*)NULL + ((const char*)tgt->args - (char*)NULL));
	}
	return;
}

#if defined __INTEL_COMPILER
# pragma warning (default:177)
#endif	/* __INTEL_COMPILER */
