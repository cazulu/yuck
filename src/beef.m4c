/* -*- c -*- */
#if defined HAVE_CONFIG_H
# include "config.h"
#endif	/* HAVE_CONFIG_H */
#include <stdbool.h>
#include <string.h>
#include "yuck.h"

static inline bool
streqp(const char *s1, const char *s2)
{
	return !strcmp(s1, s2);
}

static int parse_cmd_long(struct yuck_s *restrict tgt, const char *opt)
{
	switch (tgt->cmd) {
	foreachq([__cmd__], [YUCK_CMDS], [case __cmd__:
		if (0) {
			;
		}foreachq([__lopt__], __cmd__[_LONG], [ else if (streqp(opt, "__lopt__")) {
			YUCK_SET([tgt], __cmd__.__lopt__);
		}])
		break;
	])
	default:
		return -1;
	}
	return 0;
}

static int parse_none_long(struct yuck_s *restrict tgt, const char *opt)
{
	if (0) {
		;
	}foreachq([__lopt__], [YUCK_NONE_LONG], [ else if (streqp(opt, "__lopt__")) {
		YUCK_SET([tgt], __lopt__);
	}])
	return 0;
}

static int parse_cmd_short(struct yuck_s *restrict tgt, const char arg)
{
	switch (tgt->cmd) {
	foreachq([__cmd__], [YUCK_CMDS], [case __cmd__:
		switch (arg) {
		foreachq([__sopt__], __cmd__[_SHORT], [case '__sopt__':
			YUCK_SET([tgt], __cmd__.__sopt__);
			break;
		])
		default:
			return -1;
		}
		break;
	])
	default:
		return -1;
	}
	return 0;
}

static int parse_none_short(struct yuck_s *restrict tgt, const char arg)
{
	switch (arg) {
	foreachq([__sopt__], [YUCK_NONE_SHORT], [case '__sopt__':
		YUCK_SET([tgt], __sopt__);
		break;
	])
	default:
		return -1;
	}
	return 0;
}

static int parse_cmd(struct yuck_s *restrict tgt, const char *cmd)
{
	if (0) {
		;
	}foreachq([__cmd__], [YUCK_CMDS], [ else if (streqp(cmd, YUCK_CMDSTR_MAP(__cmd__))) {
		tgt->cmd = __cmd__;
	}]) else {
		return -1;
	}
	return 0;
}

int yuck_parse(struct yuck_s *restrict tgt, int argc, char *const argv[[]])
{
	char **args;
	size_t nargs;
	int i;

	/* we'll have at most this many args */
	args = calloc(argc, sizeof(*args));
	tgt->cmd = (enum yuck_cmds_e)0U;
	/* initial loop, no dashdash seen yet, no command seen yet */
	for (i = 1; i < argc; i++) {
		if (*argv[[i]] == '-') {
			/* could be an option */
			const char *op = argv[[i]] + 1U;

			switch (*op) {
			case '-':
				if (*++op == '\0') {
					goto dashdash;
				}
				/* long opt, parse common options only */
				parse_none_long(tgt, op);
				break;
			default:
				/* parse short common options */
				parse_none_short(tgt, *op);

				/* could be glued into one */
				for (; *op; op++) {
					/* try command specific opts */
					;

					/* and common opts now */
					;
				}
				break;
			}
		} else if (yuck_NCMDS) {
			/* finally, the moment we've been waiting for */
			parse_cmd(tgt, argv[[i]]);
			goto command;
		} else {
			/* just collect things in tgt->args */
			args[[nargs++]] = argv[[i]];
		}
	}

command:
	/* command-seen loop, parse command specific options also,
	 * we either got here by goto or if i >= argc, so in this loop
	 * it is safe to assume that the CMD is set */
	for (i++; i < argc; i++) {
		if (*argv[[i]] == '-') {
			/* could be an option */
			const char *op = argv[[i]] + 1U;

			switch (*op) {
			case '-':
				if (*++op == '\0') {
					goto dashdash;
				}
				/* long opt,
				 * try command specific options first */
				parse_cmd_long(tgt, op);
				/* and now common options */
				parse_none_long(tgt, op);
				break;
			default:
				/* try command specific opts */
				parse_cmd_short(tgt, *op);
				/* and common opts now */
				parse_none_short(tgt, *op);

				/* could be glued into one */
				for (; *op; op++) {
					/* try command specific opts */
					;

					/* and common opts now */
					;
				}
				break;
			}
		} else {
			args[[nargs++]] = argv[[i]];
		}
	}

dashdash:
	/* dashdash loop, pile everything on tgt->args
	 * don't check for subcommands either, this is in accordance to
	 * the git tool which won't accept commands after -- */
	for (i++; i < argc; i++) {
		args[[nargs++]] = argv[[i]];
	}

	tgt->nargs = nargs;
	tgt->args = args;
	return 0;
}

void yuck_free(struct yuck_s *restrict tgt)
{
	if (tgt->nargs > 0U) {
		/* free despite const qualifier */
		free((char*)NULL + ((const char*)tgt->args - (char*)NULL));
	}
	return;
}

/* beef.c ends here */
